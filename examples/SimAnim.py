#!/usr/bin/env python3

#######################################################################################################################
##! \file
##! \author Pélégrin Marius
##! \copyright The MIT License (MIT)
##! \date 2019-2024
#######################################################################################################################

import sys
import os
import shutil
import pathlib
import copy
import numpy as np
from math import log10
from PIL import Image


DEFAULT_PARSED_ARGS = {
    "input_dir": None,
    "output_dir": None,
    "tmp_dir": None,
    "t_range": [None, None],
    "length": 10.0,
    "framerate": 24.0,
    "ranges": [],
    "particles": False
}

BRIEF_USAGE = """
Usage: [python3 SimAnim.py | ./SimAnim.py] [args] <input_dir>

For more information, use "python3 SimAnim.py -h"
"""

USAGE = BRIEF_USAGE + """
Mandatory arguments are:

<input_dir>
    Directory generated by SimAnim, containing the binary frames and the
    timetables.

Possible options are:

<-h|--help>
    Displays this message.

<-f|--framerate> <framerate>
    The framerate of the final animation. Default to 24 fps.

<-t|--time_range> <begin>:<end>
    The times of begining and ending of the animation in the simulation world.
    By default, the animation begin at the first time of the timetable and end
    at the last time of the timetable.

<-l|--length> <length>
    Length of the animation in seconds. Default to 10s.

<-r|--ranges> <xMin>:<xMax>,<yMin>:<yMax>,...
    Min and max values for display purpose on each component of the frames.
    These are NOT the ranges of the axes !

<-o|--output_dir> <output_dir>
    Directory to put the final animation. Default to "<input_dir>/SimAnim".

<--tmp_dir> <tmp_dir>
    Directory to put the temporary files used to generate the animation (such
    as the individual images of each frame needed).
    Default to "<output_dir>/Tmp"
    
<-p|--particles>
    Create a particle animation. Works iff the dimension of the frames is
    "n 2". In this case, the animation size is 1024x1024 pixels and each
    particle is drawn as a pixel. Furthermore the particles must in the
    space [0, 1]²
"""


def main(args):

    print("Initialization...")

    parsed_args = parse_args(args)
    parsed_args = create_subdirs(parsed_args)

    print("Reading timetable...")
    frame_shape, input_paths, output_paths = read_timetables(parsed_args)

    if len(parsed_args["ranges"]) == 0:
        print("Computing ranges...")
        compute_ranges(parsed_args, input_paths, frame_shape)

    print("Rendering frames...")
    rendering_animation(parsed_args, input_paths, output_paths, frame_shape)


def parse_args(args):

    if "-h" in args or "--help" in args:
        print_usage(0)

    parsed_args = {key: copy.deepcopy(DEFAULT_PARSED_ARGS[key]) for key in DEFAULT_PARSED_ARGS}

    a = 1
    while a < len(args):
        arg = args[a]

        # framerate
        if arg in ["-f", "--framerate"]:
            a += 1
            if a < len(args):
                arg = args[a]
                try:
                    parsed_args["framerate"] = float(arg)
                except ValueError:
                    print("Unrecognized framerate (must be a number): " + arg + ".")
                    print_brief_usage(1)

        # t_range
        elif arg in ["-t", "--time_range"]:
            a += 1
            if a < len(args):
                arg = args[a]
                try:
                    arg = arg.split(":")
                    assert len(arg) == 2
                    parsed_args["t_range"] = [float(x) for x in arg]
                except (ValueError, AssertionError):
                    print("Unrecognized time range: " + arg + ".")
                    print_brief_usage(1)

        # length
        elif arg in ["-l", "--length"]:
            a += 1
            if a < len(args):
                arg = args[a]
                try:
                    parsed_args["length"] = float(arg)
                except ValueError:
                    print("Unrecognized animation length: " + arg + ".")
                    print_brief_usage(1)

        # ranges
        elif arg in ["-r", "--ranges"]:
            a += 1
            if a < len(args):
                arg = args[a]
                try:
                    arg = [x.split(":") for x in arg.split(",")]
                    assert False not in [len(x) == 2 for x in arg]
                    parsed_args["ranges"] = [[float(y) for y in x] for x in arg]
                except (ValueError, AssertionError):
                    print("Unrecognized ranges: " + arg + ".")
                    print_brief_usage(1)

        # particles
        elif arg in ["-p", "--particles"]:
            parsed_args["particles"] = True

        # output_dir
        elif arg in ["-o", "--output_dir"]:
            a += 1
            if a < len(args):
                parsed_args["output_dir"] = args[a]

        # tmp_dir
        elif arg in ["--tmp_dir"]:
            a += 1
            if a < len(args):
                parsed_args["tmp_dir"] = args[a]

        # input_dir
        elif parsed_args["input_dir"] is None:
            parsed_args["input_dir"] = arg

        # Unrecognized argument
        else:
            print("Unrecognized argument: " + arg + ".")
            print_brief_usage(1)

        a += 1

    if parsed_args["input_dir"] is None:
        print("Missing input and output directories.")
        print_brief_usage(1)

    return parsed_args


def print_brief_usage(exit_code):
    print(BRIEF_USAGE)
    sys.exit(exit_code)


def print_usage(exit_code):
    print(USAGE)
    sys.exit(exit_code)


def create_subdirs(parsed_args):

    if parsed_args["output_dir"] is None:
        parsed_args["output_dir"] = os.path.join(parsed_args["input_dir"], "SimAnim")

    if parsed_args["tmp_dir"] is None:
        parsed_args["tmp_dir"] = os.path.join(parsed_args["output_dir"], "Tmp")

    if os.path.exists(parsed_args["output_dir"]):
        shutil.rmtree(parsed_args["output_dir"])

    if os.path.exists(parsed_args["tmp_dir"]):
        shutil.rmtree(parsed_args["tmp_dir"])

    pathlib.Path(parsed_args["output_dir"]).mkdir(parents=True, exist_ok=True)
    pathlib.Path(parsed_args["tmp_dir"]).mkdir(parents=True, exist_ok=True)

    return parsed_args


def read_timetables(parsed_args):

    # Read timetable file
    with open(os.path.join(parsed_args["input_dir"], "time.txt"), "r") as file:
        frame_shape = [int(x) for x in file.readline().split(" ")]
        times = [float(x) for x in file.read().split("\n")[:-1]]

    # Get time range
    if parsed_args["t_range"][0] is None:
        parsed_args["t_range"][0] = times[0]

    if parsed_args["t_range"][1] is None:
        parsed_args["t_range"][1] = times[-1]

    # Compute frame indices
    image_count = int(parsed_args["length"]*parsed_args["framerate"]) + 1
    step = (parsed_args["t_range"][1] - parsed_args["t_range"][0])/(image_count - 1)
    i = 0
    t = parsed_args["t_range"][0]
    frame_indices = list()
    for _ in range(image_count):
        while i < len(times) - 1 and abs(times[i+1] - t) <= abs(times[i] - t):
            i += 1
        frame_indices.append(i+1)
        t += step

    # Compute frame input and output paths
    digit_count = int(log10(image_count)) + 1
    input_paths = list()
    output_paths = list()
    for i, index in enumerate(frame_indices):
        input_paths.append(os.path.join(parsed_args["input_dir"], "frame" + str(index) + ".bin"))
        output_paths.append(os.path.join(parsed_args["tmp_dir"], "0" * (digit_count - len(str(i))) + str(i) + ".png"))

    return frame_shape, input_paths, output_paths


def compute_ranges(parsed_args, input_paths, frame_shape):

    image_count = len(input_paths)
    min_value, max_value = float("inf"), float("-inf")
    for p, path in enumerate(input_paths):
        if p % (image_count // 161 + 1) == 0:
            print(round(100 * p / image_count, 1), "%")
        mat = load_frame(path, frame_shape)
        min_value = min(min_value, np.amin(mat))
        max_value = max(max_value, np.amax(mat))

    parsed_args["ranges"] = [[min_value, max_value]]


def load_frame(input_filename, frame_shape):

    with open(input_filename, "rb") as file:
        data = np.frombuffer(file.read(), np.float64)

    return np.reshape(data, frame_shape)


def rendering_animation(parsed_args, input_paths, output_paths, frame_shape):

    image_count = len(input_paths)
    for i in range(image_count):

        if i % (image_count // 161 + 1) == 0:
            print(round(100 * i / image_count, 1), "%")

        mat = load_frame(input_paths[i], frame_shape)

        if parsed_args["particles"]:
            size = 512
            img_mat = np.zeros((size, size), dtype=np.uint8)
            for particle in mat:
                img_mat[min(int(particle[0] * size), size - 1), min(int(particle[1] * size), size - 1)] = 255
            img = Image.fromarray(255 - img_mat)

        else:
            mat = (mat - parsed_args["ranges"][0][0]) / (parsed_args["ranges"][0][1] - parsed_args["ranges"][0][0])
            mat = 255 * np.clip(mat, 0, 1)
            mat = np.transpose(mat.astype(np.uint8))
            img = Image.fromarray(mat)

        img.save(output_paths[i])

    digit_count = int(log10(image_count)) + 1
    command = "ffmpeg -r " + str(parsed_args["framerate"])
    command += " -i " + os.path.join(parsed_args["tmp_dir"], "%0" + str(digit_count) + "d.png")
    command += " -c:v libx264 -crf 10 -c:a aac -strict -2 " + os.path.join(parsed_args["output_dir"], "SimAnim.mp4")
    os.system(command)


if __name__ == "__main__":
    main(sys.argv)
